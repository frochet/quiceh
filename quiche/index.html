<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="ðŸ¥§ Savoury implementation of the QUIC transport protocol and HTTP/3."><title>quiche - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-2c208a72533b4dd0.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="quiche" data-themes="" data-resource-suffix="" data-rustdoc-version="1.79.0-nightly (0d8b3346a 2024-04-14)" data-channel="nightly" data-search-js="search-ffac13a0df2b1870.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-e32f0c247825364d.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-c97aec732c613ca4.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-09095024cf37855e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../quiche/index.html">quiche</a><span class="version">0.21.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#constants">Constants</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Aliases</a></li></ul></section></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../quiche/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press â€˜Sâ€™ to search, â€˜?â€™ for more optionsâ€¦" type="search"><div id="help-button" tabindex="-1"><a href="../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings">Settings</a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">quiche</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/quiche/lib.rs.html#27-17170">source</a> Â· <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>ðŸ¥§ Savoury implementation of the QUIC transport protocol and HTTP/3.</p>
<p><a href="https://github.com/cloudflare/quiche/">quiche</a> is an implementation of the QUIC transport protocol and HTTP/3 as
specified by the <a href="https://quicwg.org/">IETF</a>. It provides a low level API for processing QUIC
packets and handling connection state. The application is responsible for
providing I/O (e.g. sockets handling) as well as an event loop with support
for timers.</p>
<h3 id="configuring-connections"><a class="doc-anchor" href="#configuring-connections">Â§</a>Configuring connections</h3>
<p>The first step in establishing a QUIC connection using quiche is creating a
<a href="https://docs.quic.tech/quiche/struct.Config.html"><code>Config</code></a> object:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>config = quiche::Config::new(quiche::PROTOCOL_VERSION)<span class="question-mark">?</span>;
config.set_application_protos(<span class="kw-2">&amp;</span>[<span class="string">b"example-proto"</span>]);

<span class="comment">// Additional configuration specific to application and use case...</span></code></pre></div>
<p>The <a href="https://docs.quic.tech/quiche/struct.Config.html"><code>Config</code></a> object controls important aspects of the QUIC connection such
as QUIC version, ALPN IDs, flow control, congestion control, idle timeout
and other properties or features.</p>
<p>QUIC is a general-purpose transport protocol and there are several
configuration properties where there is no reasonable default value. For
example, the permitted number of concurrent streams of any particular type
is dependent on the application running over QUIC, and other use-case
specific concerns.</p>
<p>quiche defaults several properties to zero, applications most likely need
to set these to something else to satisfy their needs using the following:</p>
<ul>
<li><a href="https://docs.rs/quiche/latest/quiche/struct.Config.html#method.set_initial_max_streams_bidi"><code>set_initial_max_streams_bidi()</code></a></li>
<li><a href="https://docs.rs/quiche/latest/quiche/struct.Config.html#method.set_initial_max_streams_uni"><code>set_initial_max_streams_uni()</code></a></li>
<li><a href="https://docs.rs/quiche/latest/quiche/struct.Config.html#method.set_initial_max_data"><code>set_initial_max_data()</code></a></li>
<li><a href="https://docs.rs/quiche/latest/quiche/struct.Config.html#method.set_initial_max_stream_data_bidi_local"><code>set_initial_max_stream_data_bidi_local()</code></a></li>
<li><a href="https://docs.rs/quiche/latest/quiche/struct.Config.html#method.set_initial_max_stream_data_bidi_remote"><code>set_initial_max_stream_data_bidi_remote()</code></a></li>
<li><a href="https://docs.rs/quiche/latest/quiche/struct.Config.html#method.set_initial_max_stream_data_uni"><code>set_initial_max_stream_data_uni()</code></a></li>
</ul>
<p><a href="https://docs.quic.tech/quiche/struct.Config.html"><code>Config</code></a> also holds TLS configuration. This can be changed by mutators on
the an existing object, or by constructing a TLS context manually and
creating a configuration using <a href="https://docs.quic.tech/quiche/struct.Config.html#method.with_boring_ssl_ctx_builder"><code>with_boring_ssl_ctx_builder()</code></a>.</p>
<p>A configuration object can be shared among multiple connections.</p>
<h4 id="connection-setup"><a class="doc-anchor" href="#connection-setup">Â§</a>Connection setup</h4>
<p>On the client-side the <a href="fn.connect.html"><code>connect()</code></a> utility function can be used to create
a new connection, while <a href="fn.accept.html"><code>accept()</code></a> is for servers:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Client connection.
</span><span class="kw">let </span>conn =
    quiche::connect(<span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span>server_name), <span class="kw-2">&amp;</span>scid, local, peer, <span class="kw-2">&amp;mut </span>config)<span class="question-mark">?</span>;

<span class="comment">// Server connection.
</span><span class="kw">let </span>conn = quiche::accept(<span class="kw-2">&amp;</span>scid, <span class="prelude-val">None</span>, local, peer, <span class="kw-2">&amp;mut </span>config)<span class="question-mark">?</span>;</code></pre></div>
<p>In both cases, the application is responsible for generating a new source
connection ID that will be used to identify the new connection.</p>
<p>The application also need to pass the address of the remote peer of the
connection: in the case of a client that would be the address of the server
it is trying to connect to, and for a server that is the address of the
client that initiated the connection.</p>
<h3 id="handling-incoming-packets"><a class="doc-anchor" href="#handling-incoming-packets">Â§</a>Handling incoming packets</h3>
<p>Using the connectionâ€™s <a href="struct.Connection.html#method.recv"><code>recv()</code></a> method the application can process
incoming packets that belong to that connection from the network:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>to = socket.local_addr().unwrap();

<span class="kw">loop </span>{
    <span class="kw">let </span>(read, from) = socket.recv_from(<span class="kw-2">&amp;mut </span>buf).unwrap();

    <span class="kw">let </span>recv_info = quiche::RecvInfo { from, to };

    <span class="kw">let </span>read = <span class="kw">match </span>conn.recv(<span class="kw-2">&amp;mut </span>buf[..read], recv_info) {
        <span class="prelude-val">Ok</span>(v) =&gt; v,

        <span class="prelude-val">Err</span>(quiche::Error::Done) =&gt; {
            <span class="comment">// Done reading.
            </span><span class="kw">break</span>;
        },

        <span class="prelude-val">Err</span>(e) =&gt; {
            <span class="comment">// An error occurred, handle it.
            </span><span class="kw">break</span>;
        },
    };
}</code></pre></div>
<p>The application has to pass a <a href="struct.RecvInfo.html"><code>RecvInfo</code></a> structure in order to provide
additional information about the received packet (such as the address it
was received from).</p>
<h3 id="generating-outgoing-packets"><a class="doc-anchor" href="#generating-outgoing-packets">Â§</a>Generating outgoing packets</h3>
<p>Outgoing packet are generated using the connectionâ€™s <a href="struct.Connection.html#method.send"><code>send()</code></a> method
instead:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">loop </span>{
    <span class="kw">let </span>(write, send_info) = <span class="kw">match </span>conn.send(<span class="kw-2">&amp;mut </span>out) {
        <span class="prelude-val">Ok</span>(v) =&gt; v,

        <span class="prelude-val">Err</span>(quiche::Error::Done) =&gt; {
            <span class="comment">// Done writing.
            </span><span class="kw">break</span>;
        },

        <span class="prelude-val">Err</span>(e) =&gt; {
            <span class="comment">// An error occurred, handle it.
            </span><span class="kw">break</span>;
        },
    };

    socket.send_to(<span class="kw-2">&amp;</span>out[..write], <span class="kw-2">&amp;</span>send_info.to).unwrap();
}</code></pre></div>
<p>The application will be provided with a <a href="struct.SendInfo.html"><code>SendInfo</code></a> structure providing
additional information about the newly created packet (such as the address
the packet should be sent to).</p>
<p>When packets are sent, the application is responsible for maintaining a
timer to react to time-based connection events. The timer expiration can be
obtained using the connectionâ€™s <a href="struct.Connection.html#method.timeout"><code>timeout()</code></a> method.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>timeout = conn.timeout();</code></pre></div>
<p>The application is responsible for providing a timer implementation, which
can be specific to the operating system or networking framework used. When
a timer expires, the connectionâ€™s <a href="struct.Connection.html#method.on_timeout"><code>on_timeout()</code></a> method should be called,
after which additional packets might need to be sent on the network:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Timeout expired, handle it.
</span>conn.on_timeout();

<span class="comment">// Send more packets as needed after timeout.
</span><span class="kw">loop </span>{
    <span class="kw">let </span>(write, send_info) = <span class="kw">match </span>conn.send(<span class="kw-2">&amp;mut </span>out) {
        <span class="prelude-val">Ok</span>(v) =&gt; v,

        <span class="prelude-val">Err</span>(quiche::Error::Done) =&gt; {
            <span class="comment">// Done writing.
            </span><span class="kw">break</span>;
        },

        <span class="prelude-val">Err</span>(e) =&gt; {
            <span class="comment">// An error occurred, handle it.
            </span><span class="kw">break</span>;
        },
    };

    socket.send_to(<span class="kw-2">&amp;</span>out[..write], <span class="kw-2">&amp;</span>send_info.to).unwrap();
}</code></pre></div>
<h4 id="pacing"><a class="doc-anchor" href="#pacing">Â§</a>Pacing</h4>
<p>It is recommended that applications <a href="https://datatracker.ietf.org/doc/html/rfc9002#section-7.7">pace</a> sending of outgoing packets to
avoid creating packet bursts that could cause short-term congestion and
losses in the network.</p>
<p>quiche exposes pacing hints for outgoing packets through the <a href="struct.SendInfo.html#structfield.at"><code>at</code></a> field
of the <a href="struct.SendInfo.html"><code>SendInfo</code></a> structure that is returned by the <a href="struct.Connection.html#method.send"><code>send()</code></a> method.
This field represents the time when a specific packet should be sent into
the network.</p>
<p>Applications can use these hints by artificially delaying the sending of
packets through platform-specific mechanisms (such as the <a href="https://man7.org/linux/man-pages/man8/tc-etf.8.html"><code>SO_TXTIME</code></a>
socket option on Linux), or custom methods (for example by using user-space
timers).</p>
<h3 id="sending-and-receiving-stream-data"><a class="doc-anchor" href="#sending-and-receiving-stream-data">Â§</a>Sending and receiving stream data</h3>
<p>After some back and forth, the connection will complete its handshake and
will be ready for sending or receiving application data.</p>
<p>Data can be sent on a stream by using the <a href="struct.Connection.html#method.stream_send"><code>stream_send()</code></a> method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">if </span>conn.is_established() {
    <span class="comment">// Handshake completed, send some data on stream 0.
    </span>conn.stream_send(<span class="number">0</span>, <span class="string">b"hello"</span>, <span class="bool-val">true</span>)<span class="question-mark">?</span>;
}</code></pre></div>
<p>The application can check whether there are any readable streams by using
the connectionâ€™s <a href="struct.Connection.html#method.readable"><code>readable()</code></a> method, which returns an iterator over all
the streams that have outstanding data to read.</p>
<p>The <a href="struct.Connection.html#method.stream_recv"><code>stream_recv()</code></a> method can then be used to retrieve the application
data from the readable stream:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">if </span>conn.is_established() {
    <span class="comment">// Iterate over readable streams.
    </span><span class="kw">for </span>stream_id <span class="kw">in </span>conn.readable() {
        <span class="comment">// Stream is readable, read until there's no more data.
        </span><span class="kw">while let </span><span class="prelude-val">Ok</span>((read, fin)) = conn.stream_recv(stream_id, <span class="kw-2">&amp;mut </span>buf) {
            <span class="macro">println!</span>(<span class="string">"Got {} bytes on stream {}"</span>, read, stream_id);
        }
    }
}</code></pre></div>
<h3 id="http3"><a class="doc-anchor" href="#http3">Â§</a>HTTP/3</h3>
<p>The quiche <a href="h3/index.html">HTTP/3 module</a> provides a high level API for sending and
receiving HTTP requests and responses on top of the QUIC transport protocol.</p>
<h3 id="congestion-control"><a class="doc-anchor" href="#congestion-control">Â§</a>Congestion Control</h3>
<p>The quiche library provides a high-level API for configuring which
congestion control algorithm to use throughout the QUIC connection.</p>
<p>When a QUIC connection is created, the application can optionally choose
which CC algorithm to use. See <a href="enum.CongestionControlAlgorithm.html"><code>CongestionControlAlgorithm</code></a> for currently
available congestion control algorithms.</p>
<p>For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>config = quiche::Config::new(quiche::PROTOCOL_VERSION).unwrap();
config.set_cc_algorithm(quiche::CongestionControlAlgorithm::Reno);</code></pre></div>
<p>Alternatively, you can configure the congestion control algorithm to use
by its name.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>config = quiche::Config::new(quiche::PROTOCOL_VERSION).unwrap();
config.set_cc_algorithm_name(<span class="string">"reno"</span>).unwrap();</code></pre></div>
<p>Note that the CC algorithm should be configured before calling <a href="fn.connect.html"><code>connect()</code></a>
or <a href="fn.accept.html"><code>accept()</code></a>. Otherwise the connection will use a default CC algorithm.</p>
<h3 id="feature-flags"><a class="doc-anchor" href="#feature-flags">Â§</a>Feature flags</h3>
<p>quiche defines a number of <a href="https://doc.rust-lang.org/cargo/reference/manifest.html#the-features-section">feature flags</a> to reduce the amount of compiled
code and dependencies:</p>
<ul>
<li>
<p><code>boringssl-vendored</code> (default): Build the vendored BoringSSL library.</p>
</li>
<li>
<p><code>boringssl-boring-crate</code>: Use the BoringSSL library provided by the
<a href="https://crates.io/crates/boring">boring</a> crate. It takes precedence over <code>boringssl-vendored</code> if both
features are enabled.</p>
</li>
<li>
<p><code>pkg-config-meta</code>: Generate pkg-config metadata file for libquiche.</p>
</li>
<li>
<p><code>ffi</code>: Build and expose the FFI API.</p>
</li>
<li>
<p><code>qlog</code>: Enable support for the <a href="https://datatracker.ietf.org/doc/html/draft-ietf-quic-qlog-main-schema">qlog</a> logging format.</p>
</li>
</ul>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="h3/index.html" title="mod quiche::h3">h3</a></div><div class="desc docblock-short">HTTP/3 wire protocol and QPACK implementation.</div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Config.html" title="struct quiche::Config">Config</a></div><div class="desc docblock-short">Stores configuration shared between multiple connections.</div></li><li><div class="item-name"><a class="struct" href="struct.Connection.html" title="struct quiche::Connection">Connection</a></div><div class="desc docblock-short">A QUIC connection.</div></li><li><div class="item-name"><a class="struct" href="struct.ConnectionError.html" title="struct quiche::ConnectionError">ConnectionError</a></div><div class="desc docblock-short">Represents information carried by <code>CONNECTION_CLOSE</code> frames.</div></li><li><div class="item-name"><a class="struct" href="struct.ConnectionId.html" title="struct quiche::ConnectionId">ConnectionId</a></div><div class="desc docblock-short">A QUIC connection ID.</div></li><li><div class="item-name"><a class="struct" href="struct.Header.html" title="struct quiche::Header">Header</a></div><div class="desc docblock-short">A QUIC packetâ€™s header.</div></li><li><div class="item-name"><a class="struct" href="struct.PathStats.html" title="struct quiche::PathStats">PathStats</a></div><div class="desc docblock-short">Statistics about the path of a connection.</div></li><li><div class="item-name"><a class="struct" href="struct.RecvInfo.html" title="struct quiche::RecvInfo">RecvInfo</a></div><div class="desc docblock-short">Ancillary information about incoming packets.</div></li><li><div class="item-name"><a class="struct" href="struct.SendInfo.html" title="struct quiche::SendInfo">SendInfo</a></div><div class="desc docblock-short">Ancillary information about outgoing packets.</div></li><li><div class="item-name"><a class="struct" href="struct.SocketAddrIter.html" title="struct quiche::SocketAddrIter">SocketAddrIter</a></div><div class="desc docblock-short">An iterator over SocketAddr.</div></li><li><div class="item-name"><a class="struct" href="struct.Stats.html" title="struct quiche::Stats">Stats</a></div><div class="desc docblock-short">Statistics about the connection.</div></li><li><div class="item-name"><a class="struct" href="struct.StreamIter.html" title="struct quiche::StreamIter">StreamIter</a></div><div class="desc docblock-short">An iterator over QUIC streams.</div></li><li><div class="item-name"><a class="struct" href="struct.TransportParams.html" title="struct quiche::TransportParams">TransportParams</a></div><div class="desc docblock-short">QUIC Transport Parameters</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.CongestionControlAlgorithm.html" title="enum quiche::CongestionControlAlgorithm">CongestionControlAlgorithm</a></div><div class="desc docblock-short">Available congestion control algorithms.</div></li><li><div class="item-name"><a class="enum" href="enum.Error.html" title="enum quiche::Error">Error</a></div><div class="desc docblock-short">A QUIC error.</div></li><li><div class="item-name"><a class="enum" href="enum.PathEvent.html" title="enum quiche::PathEvent">PathEvent</a></div><div class="desc docblock-short">A path-specific event.</div></li><li><div class="item-name"><a class="enum" href="enum.QlogLevel.html" title="enum quiche::QlogLevel">QlogLevel</a><span class="stab portability" title="Available on crate feature `qlog` only"><code>qlog</code></span></div><div class="desc docblock-short">Qlog logging level.</div></li><li><div class="item-name"><a class="enum" href="enum.Shutdown.html" title="enum quiche::Shutdown">Shutdown</a></div><div class="desc docblock-short">The side of the stream to be shut down.</div></li><li><div class="item-name"><a class="enum" href="enum.Type.html" title="enum quiche::Type">Type</a></div><div class="desc docblock-short">QUIC packet type.</div></li><li><div class="item-name"><a class="enum" href="enum.WireErrorCode.html" title="enum quiche::WireErrorCode">WireErrorCode</a></div><div class="desc docblock-short">QUIC error codes sent on the wire.</div></li></ul><h2 id="constants" class="section-header">Constants<a href="#constants" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="constant" href="constant.MAX_CONN_ID_LEN.html" title="constant quiche::MAX_CONN_ID_LEN">MAX_CONN_ID_LEN</a></div><div class="desc docblock-short">The maximum length of a connection ID.</div></li><li><div class="item-name"><a class="constant" href="constant.MIN_CLIENT_INITIAL_LEN.html" title="constant quiche::MIN_CLIENT_INITIAL_LEN">MIN_CLIENT_INITIAL_LEN</a></div><div class="desc docblock-short">The minimum length of Initial packets sent by a client.</div></li><li><div class="item-name"><a class="constant" href="constant.PROTOCOL_VERSION.html" title="constant quiche::PROTOCOL_VERSION">PROTOCOL_VERSION</a></div><div class="desc docblock-short">The current QUIC wire version.</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.accept.html" title="fn quiche::accept">accept</a></div><div class="desc docblock-short">Creates a new server-side connection.</div></li><li><div class="item-name"><a class="fn" href="fn.connect.html" title="fn quiche::connect">connect</a></div><div class="desc docblock-short">Creates a new client-side connection.</div></li><li><div class="item-name"><a class="fn" href="fn.negotiate_version.html" title="fn quiche::negotiate_version">negotiate_version</a></div><div class="desc docblock-short">Writes a version negotiation packet.</div></li><li><div class="item-name"><a class="fn" href="fn.retry.html" title="fn quiche::retry">retry</a></div><div class="desc docblock-short">Writes a stateless retry packet.</div></li><li><div class="item-name"><a class="fn" href="fn.version_is_supported.html" title="fn quiche::version_is_supported">version_is_supported</a></div><div class="desc docblock-short">Returns true if the given protocol version is supported.</div></li></ul><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.Result.html" title="type quiche::Result">Result</a></div><div class="desc docblock-short">A specialized <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> type for quiche operations.</div></li></ul></section></div></main></body></html>